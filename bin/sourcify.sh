#! /bin/bash
# THIS FILE WAS GENERATED BY SOURCIFY 0.3.0, DO NOT MAKE CHANGES IN IT.
#
# If an update is required please modify the source files and re-sourcify it.
# For more information please refer to the documentation:
# https://github.com/simonrelet/scripts/tree/sourcify-v0.3.0/sourcify/

set -euo pipefail
# @sourcify_start: script_utils.sh
# @sourcify_start: chalk.sh

# Usage: c_<color_name> <text>
c_red () { [[ -z "${CI:+x}" ]] && printf "\e[31m%s\e[0m" "$1" || printf "%s" "$1"; }
c_green () { [[ -z "${CI:+x}" ]] && printf "\e[32m%s\e[0m" "$1" || printf "%s" "$1"; }
c_yellow () { [[ -z "${CI:+x}" ]] && printf "\e[33m%s\e[0m" "$1" || printf "%s" "$1"; }
c_blue () { [[ -z "${CI:+x}" ]] && printf "\e[34m%s\e[0m" "$1" || printf "%s" "$1"; }
c_cyan () { [[ -z "${CI:+x}" ]] && printf "\e[36m%s\e[0m" "$1" || printf "%s" "$1"; }
c_grey () { [[ -z "${CI:+x}" ]] && printf "\e[90m%s\e[0m" "$1" || printf "%s" "$1"; }
c_underline () { [[ -z "${CI:+x}" ]] && printf "\e[4m%s\e[0m" "$1" || printf "%s" "$1"; }
c_bold () { [[ -z "${CI:+x}" ]] && printf "\e[1m%s\e[0m" "$1" || printf "%s" "$1"; }
# @sourcify_end: chalk.sh
# @sourcify_start: logger.sh

# Usage: print_<type> <message>
print_error ()
{
  local message="$1"

  printf "%s %s\n" "$(c_red "error")" "$message" 1>&2
}

print_warning ()
{
  local message="$1"

  printf "%s %s\n" "$(c_yellow "warning")" "$message" 1>&2
}

print_success ()
{
  local message="$1"

  printf "%s %s\n" "$(c_green "success")" "$message"
}

print_info ()
{
  local message="$1"

  printf "%s %s\n" "$(c_blue "info")" "$message"
}

print_debug ()
{
  local message="$1"

  [[ -z "${DEBUG:+x}" ]] || printf "%s %s\n" "$(c_yellow "debug")" "$message"
}

# Usage: print_step <current_step> <step_count> <message>
print_step ()
{
  local current_step="$1"
  local step_count="$2"
  local message="$3"

  printf "%s %s\n" "$(c_grey "[$current_step/$step_count]")" "$message"
}

# Usage: print_question
print_question ()
{
  printf "%s " "$(c_grey "question")"
}
# @sourcify_end: logger.sh
# @sourcify_start: git_utils.sh

# Usage: in_git
in_git ()
{
  git rev-parse --is-inside-work-tree > /dev/null 2>&1 || return 1
  return 0
}

# Usage: has_git_branch <branch_name>
has_git_branch ()
{
  local branch_name="$1"

  git rev-parse --verify "$branch_name" > /dev/null 2>&1 || return 1
  return 0
}

# Usage: get_remote_origin_url
# Examples:
#     ssh://git@stash.murex.com:7999/<project>/<repository>.git
#     https://git@stash.murex.com/scm/<project>/<repository>.git
get_remote_origin_url ()
{
  git config --get remote.origin.url
}

# Usage: get_current_project
get_current_project ()
{
  get_remote_origin_url | sed -n -E "s#.*/([^/]*)/[^/]*.git#\1#p"
}

# Usage: get_current_repository
get_current_repository ()
{
  get_remote_origin_url | sed -n -E "s#.*/([^/]*).git#\1#p"
}
# @sourcify_end: git_utils.sh

VERSION_REGEXP="^([^.]*)\.([^.]*)\.([^.]*)$"

# Usage: print_version <version>
print_version ()
{
  local version="$1"

  printf "%s\n" "$version"
}

# Usage: get_latest_version <script_url>
get_latest_version ()
{
  local script_url="$1"

  curl -s "$script_url" | sed -n -E 's/^VERSION="(.*)"$/\1/p'
}

extract_from_version ()
{
  local version="$1"
  local part="$2"

  case "$part" in
  major ) part=1 ;;
  minor ) part=2 ;;
  patch ) part=3 ;;
  esac

  printf "%s" "$version" | sed -n -E "s/$VERSION_REGEXP/\\$part/p"
}

# Usage: has_update <current_version> <script_url>
has_update ()
{
  local current_version="$1"
  local script_url="$2"
  local remote_version
  local remote_part
  local current_part

  remote_version=$(get_latest_version "$script_url")

  [[ $? -eq 0 ]] || return 2

  for i in major minor patch
  do
    remote_part="$(extract_from_version "$remote_version" "$i")"
    current_part="$(extract_from_version "$current_version" "$i")"
    [[ "$current_part" -lt "$remote_part" ]] && return 0
    [[ "$current_part" -gt "$remote_part" ]] && return 1
  done

  return 1
}

# Usage: print_request_update
print_request_update ()
{
  print_warning "You are not using the latest version of the script."
  print_warning "Please update it using the $(c_cyan "update") command."
}

# Usage: update <script_name> <script_dir> <current_version> <script_url>
update_unbounded ()
{
  local script_name="$1"
  local script_dir="$2"
  local current_version="$3"
  local script_url="$4"

  print_info "The current version of $(c_cyan "$script_name") is $(c_blue "$current_version")."

  if has_update "$current_version" "$script_url"; then
    local latest
    local new_script
    local install_script_file
    local script_file

    latest=$(get_latest_version "$script_url")
    print_info "The version $(c_green "$latest") is available."
    print_question
    read -p "Do you want to update? (y/n [default]) " res

    [[ "$res" =~ ^(y|Y|yes) ]] || (print_warning "Update canceled by the user." && exit 1)

    print_step 1 2 "Downloading..."
    new_script=$(curl -s --fail "$script_url")
    [[ -n "$new_script" ]] || print_error_and_exit "$script_name" "Could not fetch the new version of the script." "update"

    script_file="$script_dir/$script_name"
    install_script_file="$script_dir/update_$script_name.sh"

    cp "$script_file" "$script_file.tmp"

    printf "%s\n" "$new_script" > "$script_file.tmp"

    cat > "$install_script_file" << EOF
set -euo pipefail
mv "$script_file.tmp" "$script_file"
rm -f "\$0"
printf "%s %s\n" "$(c_green "success")" "New version has been installed."
printf "%s\n" "$(c_bold "Done")"
EOF

    print_step 2 2 "Installing..."
    exec /bin/bash "$install_script_file"
  else
    [[ $? -eq 1 ]] || print_error_and_exit "$script_name" "Cannot access scripts registry." "update"
    print_info "This script is up to date!"
  fi
}

# Usage: update <script_name> <script_dir> <current_version> <script_url>
update ()
{
  local script_name="$1"
  local current_version="$3"
  local script_url="$4"

  script_command_bounded "$script_name" "$script_url" "$current_version" update_unbounded "$@"
}

# Usage: print_no_help_entry <command> <script_name>
print_no_help_entry ()
{
  local command="$1"
  local script_name="$2"

  print_error "There are no help for the $(c_cyan "$command") command yet."
  print_info "Try using $(c_cyan "$script_name help")."
  exit 1
}

# Usage: print_update_help <script_name>
print_update_help ()
{
  local script_name="$1"

  cat << EOF
Usage: $(c_cyan "$script_name update")

Update the script to the latest version. A confirmation will be asked before the
update.
EOF
}

# Usage: print_error_and_exit <script_name> <message> [<command>]
print_error_and_exit ()
{
  local script_name="$1"
  local message="$2"
  local command="${3:-<command>}"

  # make sure $command is not empty
  [[ -n "$command" ]] || command="<command>"

  print_error "$message"
  print_info "Try using $(c_cyan "$script_name help") or $(c_cyan "$script_name help $command")"
  exit 1
}

# Usage: print_script_info <script_name> <script_dir> <version>
print_script_info ()
{
  local script_name="$1"
  local script_dir="$2"
  local version="$3"

  printf "\n%s %s %s\n" "$script_name" "$version" "$(c_grey "$script_dir/$script_name")"
}

# Usage: ensure_git_branch <branch_name> <script_name> <command>
ensure_git_branch ()
{
  local branch_name="$1"
  local script_name="$2"
  local command="$3"

  has_git_branch "$branch_name" || print_error_and_exit "$script_name" "The branch $(c_blue "$branch_name") doesn't exist." "${command:-}"
}

# Usage: ensure_in_git <script_name> <command>
ensure_in_git ()
{
  local script_name="$1"
  local command="$2"

  in_git || print_error_and_exit "$script_name" "You are not in a git repository." "${command:-}"
}

# Usage: script_command <script_url> <version> <command> [<params>]...
script_command ()
{
  local script_url="$1"
  local version="$2"
  local command="$3"
  shift 3

  [[ "$command" == "update_unbounded" ]] || (has_update "$version" "$script_url" && print_request_update) || true
  "$command" "$@"
}

# Usage: print_script_begin <script_name> <version>
print_script_begin ()
{
  local script_name="$1"
  local version="$2"

  printf "%s %s\n" "$(c_bold "$script_name")" "$(c_bold "$version")"
}

print_script_done ()
{
  printf "%s\n" "$(c_bold "Done")"
}

# Usage: script_command_bounded <script_name> <script_url> <version> <command> [<params>]...
script_command_bounded ()
{
  local script_name="$1"
  local script_url="$2"
  local version="$3"
  local command="$4"
  shift 4

  print_script_begin "$script_name" "$version"
  script_command "$script_url" "$version" "$command" "$@"
  print_script_done
}
# @sourcify_end: script_utils.sh
# @sourcify_start: constants.sh

VERSION="0.3.0"
SCRIPT_URL="https://raw.githubusercontent.com/simonrelet/scripts/sourcify-latest/bin/sourcify.sh"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
WARNING_COMMENT="$(cat << EOF
# THIS FILE WAS GENERATED BY SOURCIFY $VERSION, DO NOT MAKE CHANGES IN IT.
#
# If an update is required please modify the source files and re-sourcify it.
# For more information please refer to the documentation:
# https://github.com/simonrelet/scripts/tree/sourcify-v$VERSION/sourcify/
EOF
)"
# @sourcify_end: constants.sh
# @sourcify_start: usage.sh

# Usage: print_usage <name> <script_name> [<exit_code>]
print_usage ()
{
  local command="$1"
  local script_name="$2"
  local exit_code="${3:-0}"

  case "$command" in
  global )
    cat << EOF
Usage: $(c_cyan "$script_name <file>")
       $(c_cyan "$script_name <command>")

Resolve and replace $(c_cyan "source") and $(c_cyan ".") commands by the content of the file.

This allows to modularize scripts in order to simplify their development and
to still release them in a single file. Each file will only be sourced once.

When a $(c_cyan "<file>") is given, the sourcified result will be printed on the standard
output.

Sourcify blocks can be used to remove all non $(c_cyan "source") commands inside it. This
allows to execute instructions that are only relevent when the script is still
modularized. The block starts by the comments $(c_grey "# @sourcify_start") and ends at
$(c_grey "# @sourcify_end") or at the end of the file. These comments must be on
their own line. Do not use variables declared in the sourcify block, they will
also be removed.

Only the shebang of the main script will be kept, all other will be ignored.

The paths are relative to the sourcing file and must be static.

Example:
    $ $(c_cyan "cat utils.sh")
    #! /bin/bash
    greetings () { printf "Hello!\n"; }
    $ $(c_cyan "cat main.sh")
    #! /bin/bash
    # @sourcify_start
    # ensure we source utils.sh relatively to the current script folder
    pushd "\$(cd "\$(dirname "\${BASH_SOURCE[0]}")" && pwd)" > /dev/null 2>&1
    source utils.sh
    popd > /dev/null 2>&1
    # @sourcify_end
    greetings
    $ $(c_cyan "$script_name main.sh")
    #! /bin/bash
    # [...]
    # @sourcify_start: utils.sh
    greetings () { printf "Hello!\n"; }
    # @sourcify_end: utils.sh
    greetings

Commands:
    $(c_cyan "help")     Show this help
    $(c_cyan "update")   Update the script to the latest version
    $(c_cyan "version")  Show the version of this script

The output is colored by default but will automatically be turned off in a CI
environment (where the $(c_cyan "CI") environment variable is set).

Some commands have a help that can be displayed:
    $(c_cyan "$script_name help <command>")
EOF
    ;;

  update )
    print_update_help "$script_name"
    ;;

  * )
    [[ "$exit_code" -ne 0 ]] || exit_code=1
    print_no_help_entry "$command" "$script_name"
    ;;
  esac

  print_script_info "$script_name" "$SCRIPT_DIR" "$VERSION"
  exit $exit_code
}
# @sourcify_end: usage.sh
# @sourcify_start: utils.sh

# Usage: abs_dirname <relative_file_path>
abs_dirname ()
{
  local relative_file_path="$1"

  printf "%s" "$(cd "$(dirname "$relative_file_path")"; pwd)"
}

# Usage: file_already_sourced <file_path> <sourced_files>
file_already_sourced ()
{
  local file_path="$1"
  local sourced_files="$2"
  local existing_path=""

  existing_path="$(printf "%s" "$sourced_files" | sed -n -E "s#.*($file_path).*#\1#p")"
  [[ -n "$existing_path" ]] || return 1
  return 0
}
# @sourcify_end: utils.sh

SCRIPT_NAME=$(basename "${BASH_SOURCE[0]}")
SOURCED_FILES=""

# Usage: handle_source <source_line> <current_file_name>
handle_source ()
{
  local source_line="$1"
  local current_file_name="$2"
  local current_file_abs_path=""
  local file_relative_path=""
  local file_basename=""
  local file_dirname=""

  current_file_abs_path="$(pwd)/$current_file_name"
  file_relative_path="$(printf "%s" "$source_line" | cut -d' ' -f2)"
  file_basename="$(basename "$file_relative_path")"
  file_dirname="$(abs_dirname "$file_relative_path")"
  file_abs_path="$file_dirname/$file_basename"

  [[ -f "$file_relative_path" ]] || {
    print_error "In $(c_underline "$current_file_abs_path"):"
    print_error_and_exit "The file $(c_blue "$file_abs_path") doesn't exist."  "$SCRIPT_NAME"
  }

  file_already_sourced "$file_abs_path" "$SOURCED_FILES" || {
    SOURCED_FILES="${SOURCED_FILES:+$SOURCED_FILES }$file_abs_path"

    printf "# @sourcify_start: %s\n" "$file_basename"
    bundle_file "$file_dirname" "$file_basename"
    printf "# @sourcify_end: %s\n" "$file_basename"
  }
}

# Usage: bundle_file <abs_path> <file_name>
bundle_file ()
{
  local abs_path="$1"
  local file_name="$2"
  local in_source_block=false

  pushd "$abs_path" > /dev/null 2>&1

  # `IFS=''`: prevents leading/trailing whitespace from being trimmed
  # `-r`: prevents backslash escapes from being interpreted.
  # `|| [[ -n $line ]]`: prevents the last line from being ignored if it doesn't
  # end with a `\n` (since `read` returns a non-zero exit code when it
  # encounters EOF).
  while IFS='' read -r line || [[ -n "$line" ]]; do
    if [[ "$in_source_block" = true ]]; then
      case "$line" in
      .*|source* )
        handle_source "$line" "$file_name"
        ;;

      "# @sourcify_end" )
        in_source_block=false
        ;;

      * )
        # don't print it
        ;;
      esac
    else
      case "$line" in
      "# @sourcify_start" )
        in_source_block=true
        ;;

      .*|source* )
        handle_source "$line" "$file_name"
        ;;

      \#!* )
        [[ $# -eq 2 ]] || printf "%s\n%s\n\n" "$line" "$WARNING_COMMENT"
        ;;

      * )
        printf "%s\n" "$line"
        ;;
      esac
    fi
  done < "$file_name"

  popd > /dev/null 2>&1
}

# Usage: sourcify <relative_file_path>
sourcify ()
{
  local relative_file_path="$1"
  local res=""

  [[ -f "$relative_file_path" ]] || print_error_and_exit "$SCRIPT_NAME" "The file $(c_blue "$relative_file_path") doesn't exists or isn't a file."

  res="$(bundle_file "$(abs_dirname "$relative_file_path")" "$(basename "$relative_file_path")" true)"
  printf "%s\n" "$res"
}

main ()
{
  [[ $# -gt 0 ]] || print_usage "global" "$SCRIPT_NAME" 1

  local cmd="$1"
  shift

  case "$cmd" in
  -h|--help|help )
    script_command "$SCRIPT_URL" "$VERSION" print_usage "${1:-global}" "$SCRIPT_NAME"
    ;;

  -v|--version|version )
    print_version "$VERSION"
    ;;

  update )
    update "$SCRIPT_NAME" "$SCRIPT_DIR" "$VERSION" "$SCRIPT_URL"
    ;;

  * )
    sourcify "$cmd"
    ;;
  esac
}

main "$@"
