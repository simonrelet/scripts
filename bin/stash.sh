#! /bin/bash
# THIS FILE WAS GENERATED BY SOURCIFY 0.3.0, DO NOT MAKE CHANGES IN IT.
#
# If an update is required please modify the source files and re-sourcify it.
# For more information please refer to the documentation:
# https://github.com/simonrelet/scripts/tree/sourcify-v0.3.0/sourcify/

set -euo pipefail
# @sourcify_start: chalk.sh

# Usage: c_<color_name> <text>
c_red () { [[ -z "${CI:+x}" ]] && printf "\e[31m%s\e[0m" "$1" || printf "%s" "$1"; }
c_green () { [[ -z "${CI:+x}" ]] && printf "\e[32m%s\e[0m" "$1" || printf "%s" "$1"; }
c_yellow () { [[ -z "${CI:+x}" ]] && printf "\e[33m%s\e[0m" "$1" || printf "%s" "$1"; }
c_blue () { [[ -z "${CI:+x}" ]] && printf "\e[34m%s\e[0m" "$1" || printf "%s" "$1"; }
c_cyan () { [[ -z "${CI:+x}" ]] && printf "\e[36m%s\e[0m" "$1" || printf "%s" "$1"; }
c_grey () { [[ -z "${CI:+x}" ]] && printf "\e[90m%s\e[0m" "$1" || printf "%s" "$1"; }
c_underline () { [[ -z "${CI:+x}" ]] && printf "\e[4m%s\e[0m" "$1" || printf "%s" "$1"; }
c_bold () { [[ -z "${CI:+x}" ]] && printf "\e[1m%s\e[0m" "$1" || printf "%s" "$1"; }
# @sourcify_end: chalk.sh
# @sourcify_start: logger.sh

# Usage: print_<type> <message>
print_error ()
{
  local message="$1"

  printf "%s %s\n" "$(c_red "error")" "$message" 1>&2
}

print_warning ()
{
  local message="$1"

  printf "%s %s\n" "$(c_yellow "warning")" "$message" 1>&2
}

print_success ()
{
  local message="$1"

  printf "%s %s\n" "$(c_green "success")" "$message"
}

print_info ()
{
  local message="$1"

  printf "%s %s\n" "$(c_blue "info")" "$message"
}

print_debug ()
{
  local message="$1"

  [[ -z "${DEBUG:+x}" ]] || printf "%s %s\n" "$(c_yellow "debug")" "$message"
}

# Usage: print_step <current_step> <step_count> <message>
print_step ()
{
  local current_step="$1"
  local step_count="$2"
  local message="$3"

  printf "%s %s\n" "$(c_grey "[$current_step/$step_count]")" "$message"
}

# Usage: print_question
print_question ()
{
  printf "%s " "$(c_grey "question")"
}
# @sourcify_end: logger.sh
# @sourcify_start: git_utils.sh

# Usage: in_git
in_git ()
{
  git rev-parse --is-inside-work-tree > /dev/null 2>&1 || return 1
  return 0
}

# Usage: has_git_branch <branch_name>
has_git_branch ()
{
  local branch_name="$1"

  git rev-parse --verify "$branch_name" > /dev/null 2>&1 || return 1
  return 0
}

# Usage: get_remote_origin_url
# Examples:
#     ssh://git@stash.murex.com:7999/<project>/<repository>.git
#     https://git@stash.murex.com/scm/<project>/<repository>.git
get_remote_origin_url ()
{
  git config --get remote.origin.url
}

# Usage: get_current_project
get_current_project ()
{
  get_remote_origin_url | sed -n -E "s#.*/([^/]*)/[^/]*.git#\1#p"
}

# Usage: get_current_repository
get_current_repository ()
{
  get_remote_origin_url | sed -n -E "s#.*/([^/]*).git#\1#p"
}
# @sourcify_end: git_utils.sh
# @sourcify_start: script_utils.sh

VERSION_REGEXP="^([^.]*)\.([^.]*)\.([^.]*)$"

# Usage: print_version <version>
print_version ()
{
  local version="$1"

  printf "%s\n" "$version"
}

# Usage: get_latest_version <script_url>
get_latest_version ()
{
  local script_url="$1"

  curl -s "$script_url" | sed -n -E 's/^VERSION="(.*)"$/\1/p'
}

extract_from_version ()
{
  local version="$1"
  local part="$2"

  case "$part" in
  major ) part=1 ;;
  minor ) part=2 ;;
  patch ) part=3 ;;
  esac

  printf "%s" "$version" | sed -n -E "s/$VERSION_REGEXP/\\$part/p"
}

# Usage: has_update <current_version> <script_url>
has_update ()
{
  local current_version="$1"
  local script_url="$2"
  local remote_version
  local remote_part
  local current_part

  remote_version=$(get_latest_version "$script_url")

  [[ $? -eq 0 ]] || return 2

  for i in major minor patch
  do
    remote_part="$(extract_from_version "$remote_version" "$i")"
    current_part="$(extract_from_version "$current_version" "$i")"
    [[ "$current_part" -lt "$remote_part" ]] && return 0
    [[ "$current_part" -gt "$remote_part" ]] && return 1
  done

  return 1
}

# Usage: print_request_update
print_request_update ()
{
  print_warning "You are not using the latest version of the script."
  print_warning "Please update it using the $(c_cyan "update") command."
}

# Usage: update <script_name> <script_dir> <current_version> <script_url>
update_unbounded ()
{
  local script_name="$1"
  local script_dir="$2"
  local current_version="$3"
  local script_url="$4"

  print_info "The current version of $(c_cyan "$script_name") is $(c_blue "$current_version")."

  if has_update "$current_version" "$script_url"; then
    local latest
    local new_script
    local install_script_file
    local script_file

    latest=$(get_latest_version "$script_url")
    print_info "The version $(c_green "$latest") is available."
    print_question
    read -p "Do you want to update? (y/n [default]) " res

    [[ "$res" =~ ^(y|Y|yes) ]] || (print_warning "Update canceled by the user." && exit 1)

    print_step 1 2 "Downloading..."
    new_script=$(curl -s --fail "$script_url")
    [[ -n "$new_script" ]] || print_error_and_exit "$script_name" "Could not fetch the new version of the script." "update"

    script_file="$script_dir/$script_name"
    install_script_file="$script_dir/update_$script_name.sh"

    cp "$script_file" "$script_file.tmp"

    printf "%s\n" "$new_script" > "$script_file.tmp"

    cat > "$install_script_file" << EOF
set -euo pipefail
mv "$script_file.tmp" "$script_file"
rm -f "\$0"
printf "%s %s\n" "$(c_green "success")" "New version has been installed."
printf "%s\n" "$(c_bold "Done")"
EOF

    print_step 2 2 "Installing..."
    exec /bin/bash "$install_script_file"
  else
    [[ $? -eq 1 ]] || print_error_and_exit "$script_name" "Cannot access scripts registry." "update"
    print_info "This script is up to date!"
  fi
}

# Usage: update <script_name> <script_dir> <current_version> <script_url>
update ()
{
  local script_name="$1"
  local current_version="$3"
  local script_url="$4"

  script_command_bounded "$script_name" "$script_url" "$current_version" update_unbounded "$@"
}

# Usage: print_no_help_entry <command> <script_name>
print_no_help_entry ()
{
  local command="$1"
  local script_name="$2"

  print_error "There are no help for the $(c_cyan "$command") command yet."
  print_info "Try using $(c_cyan "$script_name help")."
  exit 1
}

# Usage: print_update_help <script_name>
print_update_help ()
{
  local script_name="$1"

  cat << EOF
Usage: $(c_cyan "$script_name update")

Update the script to the latest version. A confirmation will be asked before the
update.
EOF
}

# Usage: print_error_and_exit <script_name> <message> [<command>]
print_error_and_exit ()
{
  local script_name="$1"
  local message="$2"
  local command="${3:-<command>}"

  # make sure $command is not empty
  [[ -n "$command" ]] || command="<command>"

  print_error "$message"
  print_info "Try using $(c_cyan "$script_name help") or $(c_cyan "$script_name help $command")"
  exit 1
}

# Usage: print_script_info <script_name> <script_dir> <version>
print_script_info ()
{
  local script_name="$1"
  local script_dir="$2"
  local version="$3"

  printf "\n%s %s %s\n" "$script_name" "$version" "$(c_grey "$script_dir/$script_name")"
}

# Usage: ensure_git_branch <branch_name> <script_name> <command>
ensure_git_branch ()
{
  local branch_name="$1"
  local script_name="$2"
  local command="$3"

  has_git_branch "$branch_name" || print_error_and_exit "$script_name" "The branch $(c_blue "$branch_name") doesn't exist." "${command:-}"
}

# Usage: ensure_in_git <script_name> <command>
ensure_in_git ()
{
  local script_name="$1"
  local command="$2"

  in_git || print_error_and_exit "$script_name" "You are not in a git repository." "${command:-}"
}

# Usage: script_command <script_url> <version> <command> [<params>]...
script_command ()
{
  local script_url="$1"
  local version="$2"
  local command="$3"
  shift 3

  [[ "$command" == "update_unbounded" ]] || (has_update "$version" "$script_url" && print_request_update) || true
  "$command" "$@"
}

# Usage: print_script_begin <script_name> <version>
print_script_begin ()
{
  local script_name="$1"
  local version="$2"

  printf "%s %s\n" "$(c_bold "$script_name")" "$(c_bold "$version")"
}

print_script_done ()
{
  printf "%s\n" "$(c_bold "Done")"
}

# Usage: script_command_bounded <script_name> <script_url> <version> <command> [<params>]...
script_command_bounded ()
{
  local script_name="$1"
  local script_url="$2"
  local version="$3"
  local command="$4"
  shift 4

  print_script_begin "$script_name" "$version"
  script_command "$script_url" "$version" "$command" "$@"
  print_script_done
}
# @sourcify_end: script_utils.sh
# @sourcify_start: constants.sh

VERSION="5.0.2"
CONFIG_FILE_NAME=".stashrc"
USER_CONFIG="$HOME/$CONFIG_FILE_NAME"
STASH_API_HOST="https://git@stash.murex.com/rest/api/1.0"
SCRIPT_URL="https://raw.githubusercontent.com/simonrelet/scripts/stash-latest/bin/stash.sh"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
# @sourcify_end: constants.sh
# @sourcify_start: usage.sh

# Usage: print_usage <cmd> <script_name> [<exit_code>]
print_usage ()
{
  local command="$1"
  local script_name="$2"
  local exit_code="${3:-0}"

  case "$command" in
  global )
    cat << EOF
Usage: $(c_cyan "$script_name <command>")

Handle Stash API through various commands.

Commands:
    $(c_cyan "help")     Show helps
    $(c_cyan "login")    Save credentials in the user configuration file
    $(c_cyan "pr")       Create a pull request
    $(c_cyan "update")   Update the script to the latest version
    $(c_cyan "version")  Show the version of this script

Specify the user configurations in the ini-formatted file:
    $(c_blue "$USER_CONFIG")

And repository configurations in any ini-formatted files:
    $(c_blue "/path/to/git/repository/**/$CONFIG_FILE_NAME")

You can set the environment variable $(c_cyan "DEBUG") to display debug information:
    $(c_cyan "env DEBUG=true $script_name <command>")

The output is colored by default but will automatically be turned off in a CI
environment (where the $(c_cyan "CI") environment variable is set).

Some commands have a help that can be displayed:
    $(c_cyan "$script_name help <command>")
EOF
    ;;

  login )
    cat << EOF
Usage: $(c_cyan "$script_name login")

Save credentials of a Stash user in the user configuration file:
    $(c_blue "$USER_CONFIG")

The credentials must never be added in a repository configuration file.
EOF
    ;;

  pr )
    cat << EOF
Usage: $(c_cyan "$script_name pr [options]")

Create a pull request from the current branch to the a specific branch of a
specific repository. A Stash user must be logged in with the $(c_cyan "login") command.

Options:
    $(c_cyan "-b"), $(c_cyan "--branch=name")     Destination branch
    $(c_cyan "-r"), $(c_cyan "--reviewer=login")  Login of a reviewer, can be repeated

The options will override the values set in the configuration files, except for
the $(c_cyan "--reviewer") which will be merged. Arguments of long options are also required
for short options.

The repository root configuration file can contain the following variables:
    $(c_cyan "branch")      Destination branch, 'master' by default
    $(c_cyan "project")     Project name, the current one by default
    $(c_cyan "repository")  Repository name, the current one by default
    $(c_cyan "reviewer")    Login of a reviewer, can be repeated

Any other configuration file in the repository can contain the following
variables:
    $(c_cyan "reviewer")  Login of a reviewer, can be repeated

The list of reviewers will be the result of the merge of all the repository
configuration files, starting from the current folder and ending at the root
of the repository.

Any repository allowing pull requests from forks should set the $(c_cyan "project") and
$(c_cyan "repository") variables.

Example of repository root configuration file:
    project=ui
    repository=web-library
    reviewer=srelet
    reviewer=pbeitz

Also work with private repositories:
    project=~srelet
    repository=dev-scripts
    branch=dev
    reviewer=srelet
    reviewer=pbeitz

Any valid Stash login can be used as reviewer, even the current user. It will
simply be ignored by Stash.

This command can be used from any sub-folder of a git repository. If you are in
a submodule, the pull request will be created for the submodule using its own
configuration files.

Example:
    $(c_grey "# srelet is the login of the current Stash user")
    \$ $(c_cyan "cd /path/to/git/repository/")
    \$ $(c_cyan "cat $CONFIG_FILE_NAME")
    project=~srelet
    repository=awesome
    reviewer=pbeitz
    reviewer=srelet
    \$ $(c_cyan "cd /sub/folder/")
    \$ $(c_cyan "cat $CONFIG_FILE_NAME")
    reviewer=ftingaud
    \$ $(c_cyan "$script_name pr -r yfomena")
    $(c_grey "# create a pull request with the reviewers: 'ftingaud', 'pbeitz' and")
    $(c_grey "# 'yfomena' for the repository 'awesome' in the '~srelet' project")
EOF
    ;;

  update )
    print_update_help "$script_name"
    ;;

  * )
    [[ "$exit_code" -ne 0 ]] || exit_code=1
    print_no_help_entry "$command" "$script_name"
    ;;
  esac

  print_script_info "$script_name" "$SCRIPT_DIR" "$VERSION"
  exit $exit_code
}
# @sourcify_end: usage.sh
# @sourcify_start: utils.sh

# Usage: get_repo_config_files
get_repo_config_files ()
{
  local current_dir
  local repo_root

  current_dir="$(pwd)"
  repo_root="$(git rev-parse --show-toplevel)"

  while : ; do
    current_config="$current_dir/$CONFIG_FILE_NAME"
    [[ ! -f "$current_config" ]] || {
      printf "%s\n" "$current_config"
    }

    [[ "$current_dir" != "$repo_root" ]] || break
    current_dir="$(dirname "$current_dir")"
  done
}

# Usage: get_repo_root_config_file
get_repo_root_config_file ()
{
  printf "%s" "$(git rev-parse --show-toplevel)/$CONFIG_FILE_NAME"
}

# Usage: get_config_prop <config_file> <prop_name>
get_config_prop ()
{
  local config_file="$1"
  local prop_name="$2"

  [[ -f "$config_file" ]] && sed -n -E "s/^$prop_name=(.*)$/\1/p" "$config_file" || printf ""
}

# Usage: get_user_config_prop <prop_name>
get_user_config_prop ()
{
  local prop_name="$1"

  get_config_prop "$USER_CONFIG" "$prop_name"
}

# Usage: get_repo_root_config_prop <prop_name>
get_repo_root_config_prop ()
{
  local prop_name="$1"

  get_config_prop "$(get_repo_root_config_file)" "$prop_name"
}

# Usage: get_repo_reviewers
get_repo_reviewers ()
{
  for repo_config_file in $(get_repo_config_files)
  do
    get_config_prop "$repo_config_file" "reviewer"
  done
}

# Usage: set_config_prop <prop_name> <prop_value>
set_config_prop ()
{
  local prop_name="$1"
  local prop_value="$2"
  local without=""

  [[ -f "$USER_CONFIG" ]] && without=$(sed -n "/^$prop_name=/!p" "$USER_CONFIG")
  printf "%s%s=%s\n" "${without:+without\n}" "$prop_name" "$prop_value" > "$USER_CONFIG"
}

# Usaget_: reviewers_from_configs
get_reviewers_from_configs ()
{
  local reviewers=""

  for rev in $(get_repo_reviewers)
  do
    reviewers="${reviewers:+$reviewers,}$(format_user $rev)"
  done

  printf "%s" "$reviewers"
}

# Usage: is_auth
is_auth ()
{
  local auth
  auth=$(get_user_config_prop "auth")

  [[ -z "$auth" ]] || return 0
  return 1
}

# Usage: has_jq
has_jq ()
{
  jq --version > /dev/null 2>&1 || return 1
  return 0
}

# Usage: format_user <stash_login>
format_user ()
{
  local stash_login="$1"

  printf '{ "user": { "name": "%s" }}' "$stash_login"
}

# Usage: has_request_errors <json_result>
has_request_errors ()
{
  local json_result="$1"

  [[ "$(printf "%s" "$json_result" | jq -M .errors)" == "null" ]] || return 0
  return 1
}

# Usage: clean_message
clean_message ()
{
  sed -n -E "s/^\"(.*)\"$/\1/p" | sed -E "s/\\\\\"/\"/g"
}

# Usage: print_request_errors <json_result> <script_name>
print_request_errors ()
{
  local json_result="$1"
  local script_name="$2"
  local messages

  messages="$(printf "%s" "$json_result" | jq -M '.errors[].message' | clean_message | sed -n -E "s/^(.*)/    \1/p")"

  print_error_and_exit "$script_name" "$(cat << EOF
Pull request creation failed:
$messages
EOF
  )" "pr"
}

# Usage: print_request_confirmation <json_result>
print_request_confirmation ()
{
  local json_result="$1"
  local url

  url="$(printf "%s" "$json_result" | jq -M .links.self[0].href | clean_message)"

  print_success "$(cat << EOF
Pull request created:
    $(c_blue "$url")
EOF
  )"
}
# @sourcify_end: utils.sh

SCRIPT_NAME=$(basename "${BASH_SOURCE[0]}")

login ()
{
  local token

  ! is_auth || print_warning "Overriding existing user, type $(c_cyan "CTRL-C") to cancel."

  print_question
  read -p "Stash username: " username
  print_question
  read -s -p "Stash password: " password
  printf "\n"

  token=$(printf "%s:%s" "$username" "$password" | base64)
  set_config_prop "auth" "$token"

  print_success "Your identification token has been saved in $(c_blue "$USER_CONFIG")"
  print_success "You can now use the command $(c_cyan "$SCRIPT_NAME pr")."
  print_warning "Do not share this token."
  print_warning "Do not add it to a repository configuration file."
}

post_request_advanced ()
{
  local data="$1"
  local project="$2"
  local repo="$3"
  local token="$4"
  shift 4

  local res
  res="$(
    curl -s                                   \
         -X POST                              \
         -H 'Content-Type: application/json'  \
         -H "Authorization: Basic $token"     \
         -d "$data"                           \
         "$STASH_API_HOST/projects/$project/repos/$repo/pull-requests/"
  )"

  has_request_errors "$res" && print_request_errors "$res" "$SCRIPT_NAME" || print_request_confirmation "$res"
}

post_request_reduced ()
{
  local data="$1"
  local project="$2"
  local repo="$3"
  local token="$4"
  shift 4

  curl -s -S --fail                         \
       -o /dev/null                         \
       -X POST                              \
       -H 'Content-Type: application/json'  \
       -H "Authorization: Basic $token"     \
       -d "$data"                           \
       "$STASH_API_HOST/projects/$project/repos/$repo/pull-requests/"

 print_success "Pull request created."
}

post_request ()
{
  print_step 2 2 "Creating pull request..."
  has_jq && post_request_advanced "$@" || post_request_reduced "$@"
}

pr ()
{
  ensure_in_git "$SCRIPT_NAME" "pr"
  is_auth || print_error_and_exit "$SCRIPT_NAME" "A stash user must be logged in." "pr"

  has_jq || print_warning "Consider installing jq to display nicer feedback messages ($(c_blue "https://stedolan.github.io/jq/"))"

  local src=""
  local dst=""
  local project_src=""
  local repo_src=""
  local project_dst=""
  local repo_dst=""
  local title=""
  local commits=""
  local token=""
  local reviewers=""
  local json=""

  print_step 1 2 "Resolving repository..."

  while [[ $# -gt 0 ]]; do
    case "$1" in
    --branch=* ) dst="${1#*=}";;
    -b )
      shift
      [[ $# -gt 0 ]] && dst="$1" || print_error_and_exit "$SCRIPT_NAME" "The branch name is missing after the option $(c_cyan "-b")." "pr"
      ;;

    --reviewer=* ) reviewers="${reviewers:+$reviewers,}$(format_user "${1#*=}")";;
    -r )
      shift
      [[ $# -gt 0 ]] && reviewers="${reviewers:+$reviewers,}$(format_user "$1")" || print_error_and_exit "$SCRIPT_NAME" "The login of the reviewer is missing after the option $(c_cyan "-r")." "pr"
      ;;

    * ) print_warning "Unknown option $(c_cyan "$1").";;
    esac
    shift
  done

  src=$(git rev-parse --abbrev-ref HEAD)
  title="$src"
  token=$(get_user_config_prop "auth")

  dst="${dst:-$(get_repo_root_config_prop "branch")}"
  dst="${dst:-master}"

  project_src=$(get_current_project)
  repo_src=$(get_current_repository)

  project_dst=$(get_repo_root_config_prop "project")
  repo_dst=$(get_repo_root_config_prop "repository")

  project_dst=${project_dst:-$project_src}
  repo_dst="${repo_dst:-$repo_src}"

  ensure_git_branch "origin/$dst" "$SCRIPT_NAME" "pr"
  commits="$(git log --pretty="    %s" "$src" --not "origin/$dst")"

  [[ -n "$commits" ]] || print_error_and_exit "$SCRIPT_NAME" "There seem to be no commit between the branch $(c_blue "$src") and $(c_blue "origin/$dst")." "pr"

  print_info "$(cat << EOF
Commits in pull request:
$commits
EOF
  )"

  reviewers="${reviewers:+$reviewers,}$(get_reviewers_from_configs)"

  json="$(cat << EOF
{
  "title": "$title",
  "description": "",
  "state": "OPEN",
  "open": true,
  "closed": false,
  "fromRef": {
    "id": "refs/heads/$src",
    "repository": {
      "slug": "$repo_src",
      "name": null,
      "project": {
        "key": "$project_src"
      }
    }
  },
  "toRef": {
    "id": "refs/heads/$dst",
    "repository": {
      "slug": "$repo_dst",
      "name": null,
      "project": {
        "key": "$project_dst"
      }
    }
  },
  "locked": false,
  "reviewers": [$reviewers]
}
EOF
  )"

  print_debug "Body: $json"

  post_request "$json" "$project_dst" "$repo_dst" "$token"
}

main ()
{
  [[ $# -gt 0 ]] || print_usage "global" "$SCRIPT_NAME" 1

  local cmd="$1"
  shift

  case "$cmd" in
  -h|--help|help )
    script_command "$SCRIPT_URL" "$VERSION" print_usage "${1:-global}" "$SCRIPT_NAME"
    ;;

  -v|--version|version )
    print_version "$VERSION"
    ;;

  login )
    script_command_bounded "$SCRIPT_NAME" "$SCRIPT_URL" "$VERSION" login "$@"
    ;;

  pr )
    script_command_bounded "$SCRIPT_NAME" "$SCRIPT_URL" "$VERSION" pr "$@"
    ;;

  update )
    update "$SCRIPT_NAME" "$SCRIPT_DIR" "$VERSION" "$SCRIPT_URL"
    ;;

  * )
    print_error_and_exit "$SCRIPT_NAME" "Unknown command $(c_cyan "$cmd")."
    ;;
  esac
}

main "$@"
