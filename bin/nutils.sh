#! /bin/bash
# THIS FILE WAS GENERATED BY SOURCIFY 0.3.0, DO NOT MAKE CHANGES IN IT.
#
# If an update is required please modify the source files and re-sourcify it.
# For more information please refer to the documentation:
# https://github.com/simonrelet/scripts/tree/sourcify-v0.3.0/sourcify/

set -euo pipefail
# @sourcify_start: chalk.sh

# Usage: c_<color_name> <text>
c_red () { [[ -z "${CI:+x}" ]] && printf "\e[31m%s\e[0m" "$1" || printf "%s" "$1"; }
c_green () { [[ -z "${CI:+x}" ]] && printf "\e[32m%s\e[0m" "$1" || printf "%s" "$1"; }
c_yellow () { [[ -z "${CI:+x}" ]] && printf "\e[33m%s\e[0m" "$1" || printf "%s" "$1"; }
c_blue () { [[ -z "${CI:+x}" ]] && printf "\e[34m%s\e[0m" "$1" || printf "%s" "$1"; }
c_cyan () { [[ -z "${CI:+x}" ]] && printf "\e[36m%s\e[0m" "$1" || printf "%s" "$1"; }
c_grey () { [[ -z "${CI:+x}" ]] && printf "\e[90m%s\e[0m" "$1" || printf "%s" "$1"; }
c_underline () { [[ -z "${CI:+x}" ]] && printf "\e[4m%s\e[0m" "$1" || printf "%s" "$1"; }
c_bold () { [[ -z "${CI:+x}" ]] && printf "\e[1m%s\e[0m" "$1" || printf "%s" "$1"; }
# @sourcify_end: chalk.sh
# @sourcify_start: logger.sh

# Usage: print_<type> <message>
print_error ()
{
  local message="$1"

  printf "%s %s\n" "$(c_red "error")" "$message" 1>&2
}

print_warning ()
{
  local message="$1"

  printf "%s %s\n" "$(c_yellow "warning")" "$message" 1>&2
}

print_success ()
{
  local message="$1"

  printf "%s %s\n" "$(c_green "success")" "$message"
}

print_info ()
{
  local message="$1"

  printf "%s %s\n" "$(c_blue "info")" "$message"
}

print_debug ()
{
  local message="$1"

  [[ -z "${DEBUG:+x}" ]] || printf "%s %s\n" "$(c_yellow "debug")" "$message"
}

# Usage: print_step <current_step> <step_count> <message>
print_step ()
{
  local current_step="$1"
  local step_count="$2"
  local message="$3"

  printf "%s %s\n" "$(c_grey "[$current_step/$step_count]")" "$message"
}

# Usage: print_question
print_question ()
{
  printf "%s " "$(c_grey "question")"
}
# @sourcify_end: logger.sh
# @sourcify_start: script_utils.sh
# @sourcify_start: git_utils.sh

# Usage: in_git
in_git ()
{
  git rev-parse --is-inside-work-tree > /dev/null 2>&1 || return 1
  return 0
}

# Usage: has_git_branch <branch_name>
has_git_branch ()
{
  local branch_name="$1"

  git rev-parse --verify "$branch_name" > /dev/null 2>&1 || return 1
  return 0
}

# Usage: get_remote_origin_url
# Examples:
#     ssh://git@stash.murex.com:7999/<project>/<repository>.git
#     https://git@stash.murex.com/scm/<project>/<repository>.git
get_remote_origin_url ()
{
  git config --get remote.origin.url
}

# Usage: get_current_project
get_current_project ()
{
  get_remote_origin_url | sed -n -E "s#.*/([^/]*)/[^/]*.git#\1#p"
}

# Usage: get_current_repository
get_current_repository ()
{
  get_remote_origin_url | sed -n -E "s#.*/([^/]*).git#\1#p"
}
# @sourcify_end: git_utils.sh

VERSION_REGEXP="^([^.]*)\.([^.]*)\.([^.]*)$"

# Usage: print_version <version>
print_version ()
{
  local version="$1"

  printf "%s\n" "$version"
}

# Usage: get_latest_version <script_url>
get_latest_version ()
{
  local script_url="$1"

  curl -s "$script_url" | sed -n -E 's/^VERSION="(.*)"$/\1/p'
}

extract_from_version ()
{
  local version="$1"
  local part="$2"

  case "$part" in
  major ) part=1 ;;
  minor ) part=2 ;;
  patch ) part=3 ;;
  esac

  printf "%s" "$version" | sed -n -E "s/$VERSION_REGEXP/\\$part/p"
}

# Usage: has_update <current_version> <script_url>
has_update ()
{
  local current_version="$1"
  local script_url="$2"
  local remote_version
  local remote_part
  local current_part

  remote_version=$(get_latest_version "$script_url")

  [[ $? -eq 0 ]] || return 2

  for i in major minor patch
  do
    remote_part="$(extract_from_version "$remote_version" "$i")"
    current_part="$(extract_from_version "$current_version" "$i")"
    [[ "$current_part" -lt "$remote_part" ]] && return 0
    [[ "$current_part" -gt "$remote_part" ]] && return 1
  done

  return 1
}

# Usage: print_request_update
print_request_update ()
{
  print_warning "You are not using the latest version of the script."
  print_warning "Please update it using the $(c_cyan "update") command."
}

# Usage: update <script_name> <script_dir> <current_version> <script_url>
update_unbounded ()
{
  local script_name="$1"
  local script_dir="$2"
  local current_version="$3"
  local script_url="$4"

  print_info "The current version of $(c_cyan "$script_name") is $(c_blue "$current_version")."

  if has_update "$current_version" "$script_url"; then
    local latest
    local new_script
    local install_script_file
    local script_file

    latest=$(get_latest_version "$script_url")
    print_info "The version $(c_green "$latest") is available."
    print_question
    read -p "Do you want to update? (y/n [default]) " res

    [[ "$res" =~ ^(y|Y|yes) ]] || (print_warning "Update canceled by the user." && exit 1)

    print_step 1 2 "Downloading..."
    new_script=$(curl -s --fail "$script_url")
    [[ -n "$new_script" ]] || print_error_and_exit "$script_name" "Could not fetch the new version of the script." "update"

    script_file="$script_dir/$script_name"
    install_script_file="$script_dir/update_$script_name.sh"

    cp "$script_file" "$script_file.tmp"

    printf "%s\n" "$new_script" > "$script_file.tmp"

    cat > "$install_script_file" << EOF
set -euo pipefail
mv "$script_file.tmp" "$script_file"
rm -f "\$0"
printf "%s %s\n" "$(c_green "success")" "New version has been installed."
printf "%s\n" "$(c_bold "Done")"
EOF

    print_step 2 2 "Installing..."
    exec /bin/bash "$install_script_file"
  else
    [[ $? -eq 1 ]] || print_error_and_exit "$script_name" "Cannot access scripts registry." "update"
    print_info "This script is up to date!"
  fi
}

# Usage: update <script_name> <script_dir> <current_version> <script_url>
update ()
{
  local script_name="$1"
  local current_version="$3"
  local script_url="$4"

  script_command_bounded "$script_name" "$script_url" "$current_version" update_unbounded "$@"
}

# Usage: print_no_help_entry <command> <script_name>
print_no_help_entry ()
{
  local command="$1"
  local script_name="$2"

  print_error "There are no help for the $(c_cyan "$command") command yet."
  print_info "Try using $(c_cyan "$script_name help")."
  exit 1
}

# Usage: print_update_help <script_name>
print_update_help ()
{
  local script_name="$1"

  cat << EOF
Usage: $(c_cyan "$script_name update")

Update the script to the latest version. A confirmation will be asked before the
update.
EOF
}

# Usage: print_error_and_exit <script_name> <message> [<command>]
print_error_and_exit ()
{
  local script_name="$1"
  local message="$2"
  local command="${3:-<command>}"

  # make sure $command is not empty
  [[ -n "$command" ]] || command="<command>"

  print_error "$message"
  print_info "Try using $(c_cyan "$script_name help") or $(c_cyan "$script_name help $command")"
  exit 1
}

# Usage: print_script_info <script_name> <script_dir> <version>
print_script_info ()
{
  local script_name="$1"
  local script_dir="$2"
  local version="$3"

  printf "\n%s %s %s\n" "$script_name" "$version" "$(c_grey "$script_dir/$script_name")"
}

# Usage: ensure_git_branch <branch_name> <script_name> <command>
ensure_git_branch ()
{
  local branch_name="$1"
  local script_name="$2"
  local command="$3"

  has_git_branch "$branch_name" || print_error_and_exit "$script_name" "The branch $(c_blue "$branch_name") doesn't exist." "${command:-}"
}

# Usage: ensure_in_git <script_name> <command>
ensure_in_git ()
{
  local script_name="$1"
  local command="$2"

  in_git || print_error_and_exit "$script_name" "You are not in a git repository." "${command:-}"
}

# Usage: script_command <script_url> <version> <command> [<params>]...
script_command ()
{
  local script_url="$1"
  local version="$2"
  local command="$3"
  shift 3

  [[ "$command" == "update_unbounded" ]] || (has_update "$version" "$script_url" && print_request_update) || true
  "$command" "$@"
}

# Usage: print_script_begin <script_name> <version>
print_script_begin ()
{
  local script_name="$1"
  local version="$2"

  printf "%s %s\n" "$(c_bold "$script_name")" "$(c_bold "$version")"
}

print_script_done ()
{
  printf "%s\n" "$(c_bold "Done")"
}

# Usage: script_command_bounded <script_name> <script_url> <version> <command> [<params>]...
script_command_bounded ()
{
  local script_name="$1"
  local script_url="$2"
  local version="$3"
  local command="$4"
  shift 4

  print_script_begin "$script_name" "$version"
  script_command "$script_url" "$version" "$command" "$@"
  print_script_done
}
# @sourcify_end: script_utils.sh
# @sourcify_start: constants.sh

VERSION="0.5.0"
SCRIPT_URL="https://raw.githubusercontent.com/simonrelet/scripts/nutils-latest/bin/nutils.sh"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
# @sourcify_end: constants.sh
# @sourcify_start: usage.sh

# Usage: print_usage <name> <script_name> [<exit_code>]
print_usage ()
{
  local command="$1"
  local script_name="$2"
  local exit_code="${3:-0}"

  case "$command" in
  global )
    cat << EOF
Usage $(c_cyan "$script_name <command>")

Handle utility commands for NodeJS.

Commands:
    $(c_cyan "help")     Show helps
    $(c_cyan "ln")       Link packages
    $(c_cyan "update")   Update the script to the latest version
    $(c_cyan "version")  Show the version of this script

The output is colored by default but will automatically be turned off in a CI
environment (where the $(c_cyan "CI") environment variable is set).

Some commands have a help that can be displayed:
    $(c_cyan "$script_name help <command>")
EOF
    ;;

  ln )
    cat << EOF
Usage: $(c_cyan "$script_name ln <package>")

Create a symbolic link from a given package to its corresponding folder under
$(c_blue "node_modules/"). This allows working on both packages without the need
of reinstalling them.

This command will not install the package but simply replace the installed
folder with a symbolic link. It also works with scoped packages.

Example:
    \$ $(c_cyan "pwd")
    /packages/awesome-feature
    \$ $(c_cyan "$script_name ln ../common-package/dist")
    $(c_grey "# now all changes in /packages/common-package/dist will be visible in")
    $(c_grey "# /packages/awesome-feature/node_modules/@murex/common-package")
EOF
    ;;

  update )
    print_update_help "$script_name"
    ;;

  * )
    [[ "$exit_code" -ne 0 ]] || exit_code=1
    print_no_help_entry "$command" "$script_name"
    ;;
  esac

  print_script_info "$script_name" "$SCRIPT_DIR" "$VERSION"
  exit $exit_code
}
# @sourcify_end: usage.sh

SCRIPT_NAME=$(basename "${BASH_SOURCE[0]}")

# Usage: get_from_pkg <package_file> <field_name>
get_from_pkg ()
{
  local package_file="$1"
  local field_name="$2"

  cat "$package_file" | sed -n -E "s/.*\"$field_name\".*:.*\"(.*)\".*/\1/p"
}

# Usage: link_package <other_package>
link_package ()
{
  [[ $# -eq 1 ]] || print_error_and_exit "$SCRIPT_NAME" "The path of the package to link is missing." "ln"

  local other_package_dir="${1%/package.json}"
  other_package_dir="${other_package_dir%/}"
  local other_package_file="$other_package_dir/package.json"
  local other_package_abs_dir
  local other_package_abs_file
  local other_package_name
  local other_package_version
  local other_package_scope
  local dst_dir="node_modules"

  print_step 1 2 "Resolving packages..."

  [[ -f "$(pwd)/package.json" ]] || print_error_and_exit "$SCRIPT_NAME" "You are not in a node package." "ln"
  [[ -f "$other_package_file" ]] || print_error_and_exit "$SCRIPT_NAME" "The file $(c_blue "$other_package_file") doesn't exist." "ln"

  other_package_abs_dir="$(cd "$other_package_dir" && pwd)"
  other_package_abs_file="$other_package_abs_dir/package.json"

  other_package_name="$(get_from_pkg "$other_package_abs_file" name)"
  other_package_version="$(get_from_pkg "$other_package_abs_file" version)"
  [[ -n "$other_package_name" ]] || print_error_and_exit "$SCRIPT_NAME" "Make sure that $(c_blue "$other_package_file") contains a $(c_cyan "name") field." "ln"
  [[ -n "$other_package_version" ]] || print_error_and_exit "$SCRIPT_NAME" "Make sure that $(c_blue "$other_package_file") contains a $(c_cyan "version") field." "ln"

  print_debug "Found node package $(c_cyan "$other_package_name@$other_package_version")"

  rm -rf "node_modules/$other_package_name"
  other_package_scope="$(dirname "$other_package_name")"
  dst_dir="${other_package_scope:+$dst_dir/$other_package_scope}"

  print_step 2 2 "Linking packages..."

  [[ -d "$dst_dir" ]] || mkdir "$dst_dir"
  ln -s "$other_package_abs_dir" "$(pwd)/node_modules/$other_package_name"

  print_success "Package $(c_cyan "$other_package_name@$other_package_version") has been linked."
}

main ()
{
  [[ $# -gt 0 ]] || print_usage "global" "$SCRIPT_NAME" 1

  local cmd="$1"
  shift

  case "$cmd" in
  -h|--help|help )
    script_command "$SCRIPT_URL" "$VERSION" print_usage "${1:-global}" "$SCRIPT_NAME"
    ;;

  -v|--version|version )
    print_version "$VERSION"
    ;;

  ln )
    script_command_bounded "$SCRIPT_NAME" "$SCRIPT_URL" "$VERSION" link_package "$@"
    ;;

  update )
    update "$SCRIPT_NAME" "$SCRIPT_DIR" "$VERSION" "$SCRIPT_URL"
    ;;

  * )
    print_error_and_exit "$SCRIPT_NAME" "Unknown command $(c_cyan "$cmd")."
    ;;
  esac
}

main "$@"
